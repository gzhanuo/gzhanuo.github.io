<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[高效输入：Emmet使用手册]]></title>
    <url>%2Farticles%2F2184704117%2F</url>
    <content type="text"><![CDATA[在前端开发的过程中，很大一部分工作是写HTML，CSS代码。数量繁多的标签、属性、尖括号、标签闭合等，往往导致开发过程十分繁琐且效率不高。Emmet（前身为Zen Coding）是一套面向文本编辑器的插件，它允许通过内容辅助高速度的编写和编辑HTML、XML、XSL和其他结构化的代码格式，是一个能大幅提高前端开发效率的工具。它使用特定的语法来展开小段代码，类似CSS选择器，使其成为完整的HTML结构或CSS代码。在前端开发的过程中，很大一部分工作是写HTML，CSS代码。数量繁多的标签、属性、尖括号、标签闭合等，往往导致开发过程十分繁琐且效率不高。Emmet（前身为Zen Coding）是一套面向文本编辑器的插件，它允许通过内容辅助高速度的编写和编辑HTML、XML、XSL和其他结构化的代码格式，是一个能大幅提高前端开发效率的工具。它使用特定的语法来展开小段代码，类似CSS选择器，使其成为完整的HTML结构或CSS代码。Emmet官方提供多编辑器支持，具体安装使用方法可参考官网介绍。我个人习惯使用VS Code，当前版本已内置Emmet语法，无需安装插件。本文仅介绍部分常用语法，完整API列表可参考官方文档。HTML缩写缩写（Abbreviations）是Emmet工具包的核心：这些特殊表达式在运行时解析并转换为结构化代码块，例如HTML。缩写的语法看起来像CSS选择器，具有一些特定于代码生成的扩展。元素(Elements)你可以使用元素的名字，如div或p来生成HTML标签。Emmet没有预定义的可用标签名称集，所以你可以编写任何单词并将其转换为标签：div→ &lt;div&gt;&lt;/div&gt;，foo→ &lt;foo&gt;&lt;/foo&gt;依此类推。嵌套操作符(Nesting operators)嵌套操作符用于在生成的树中定位缩写元素：是否应将其放置在context元素的内部或附近。子级(Child): &gt;通过&gt;可生成嵌套子级元素，可以配合元素属性进行连写。1234567div&gt;ul&gt;li&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;同级(Sibling): +通过+连接元素，可生成同级元素。12345div+p+bq&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;/blockquote&gt;父级(Climb-up): ^^用于生成父级元素的同级元素,从这个^字符所在位置开始,查找左侧最近的元素的父级元素并生成其兄弟元素。1234567div+div&gt;p&gt;span+em^bq&lt;div&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt; &lt;blockquote&gt;&lt;/blockquote&gt;&lt;/div&gt;可以使用任意数量的^操作符，每个操作符将向上移动一级。1234567div+div&gt;p&gt;span+em^^^bq&lt;div&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;/blockquote&gt;乘法(Multiplication): *使用*可定义重复项，后跟一个正整数表示重复次数。123456789ul&gt;li*5&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;分组(Group): ()使用()可对复杂缩写中的子树分组。在下面这个例子中，如果不加括号进行分组，footer将作为a的同级元素生成。12345678910111213div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p&lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt;属性操作符(Attribute operators)属性运算符用于修改输出元素的属性。例如，在HTML和XML中，你可以快速向生成的元素添加class属性。ID和CLASS在Emmet中，可以使用elem#id和elem.class将这些属性添加到指定的元素上。12345div#header+div.page+div#footer.class1.class2.class3&lt;div id="header"&gt;&lt;/div&gt;&lt;div class="page"&gt;&lt;/div&gt;&lt;div id="footer" class="class1 class2 class3"&gt;&lt;/div&gt;自定义属性(Custom attributes)可以使用[attr]表示法向元素添加自定义属性。123td[title="Hello world!" colspan=3]&lt;td title="Hello world!" colspan="3"&gt;&lt;/td&gt;自动计数(Item numbering)使用*操作符生成重复元素时，可以加上$对它们进行编号。将$操作符放在元素的名称，属性的名称或属性的值中，以输出重复元素的当前数量。123456789ul&gt;li.item$*5&lt;ul&gt; &lt;li class="item1"&gt;&lt;/li&gt; &lt;li class="item2"&gt;&lt;/li&gt; &lt;li class="item3"&gt;&lt;/li&gt; &lt;li class="item4"&gt;&lt;/li&gt; &lt;li class="item5"&gt;&lt;/li&gt;&lt;/ul&gt;可以使用多个连续$用零填充数字：123456789ul&gt;li.item$$$*5&lt;ul&gt; &lt;li class="item001"&gt;&lt;/li&gt; &lt;li class="item002"&gt;&lt;/li&gt; &lt;li class="item003"&gt;&lt;/li&gt; &lt;li class="item004"&gt;&lt;/li&gt; &lt;li class="item005"&gt;&lt;/li&gt;&lt;/ul&gt;同时，也可以使用@修改器更改编号方向（升序或降序）和基础值（例如起始值）。例如，如果要修改编号方向，可以在$后添加@-：123456789ul&gt;li.item$@-*5&lt;ul&gt; &lt;li class="item5"&gt;&lt;/li&gt; &lt;li class="item4"&gt;&lt;/li&gt; &lt;li class="item3"&gt;&lt;/li&gt; &lt;li class="item2"&gt;&lt;/li&gt; &lt;li class="item1"&gt;&lt;/li&gt;&lt;/ul&gt;如果要修改基础值，可以在$后面添加@N，N为正整数，表示基础值：123456789ul&gt;li.item$@3*5&lt;ul&gt; &lt;li class="item3"&gt;&lt;/li&gt; &lt;li class="item4"&gt;&lt;/li&gt; &lt;li class="item5"&gt;&lt;/li&gt; &lt;li class="item6"&gt;&lt;/li&gt; &lt;li class="item7"&gt;&lt;/li&gt;&lt;/ul&gt;文本操作符(Text): {}可以使用花括号向元素添加文本。123a&#123;Click me&#125;&lt;a href=""&gt;Click me&lt;/a&gt;主要注意的是，{text}被用作同时也被解析为独立的元素（类似div和p），但当置于元素右侧时具有特殊含义。例如，a{click}并且a&gt;{click}会产生相同的输出，但a{click}+b{here}和a&gt;{click}+b{here}并不会：12345&lt;!-- a&#123;click&#125;+b&#123;here&#125; --&gt;&lt;a href=""&gt;click&lt;/a&gt;&lt;b&gt;here&lt;/b&gt;&lt;!-- a&gt;&#123;click&#125;+b&#123;here&#125; --&gt;&lt;a href=""&gt;click&lt;b&gt;here&lt;/b&gt;&lt;/a&gt;HTML文档初始结构每个HTML文档都包含一些固定的标签，像html、head、body等。在Emmet中，输入!或者html:5，按下Tab键，可以快速生成HTML文档初始结构。123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;隐式标签隐式标签意味着，多数情况下，Emmet允许你省略某些标签名。例如，如果想要生成一个类名为content的div元素，可以将div.content简单地写为.content，结果同样会生成&lt;div class=&quot;content&quot;&gt;&lt;/div&gt;。此外，Emmet会根据父元素判定将要生成的标签，例如，输入ul&gt;.item$*5将会生成如下结构：1234567&lt;ul&gt; &lt;li class="item1"&gt;&lt;/li&gt; &lt;li class="item2"&gt;&lt;/li&gt; &lt;li class="item3"&gt;&lt;/li&gt; &lt;li class="item4"&gt;&lt;/li&gt; &lt;li class="item5"&gt;&lt;/li&gt;&lt;/ul&gt;下面是一些解析的方式：li用于ul和ol中tr用于table、tbody、thead和tfoot中td用于tr中option用于select和optgroup中生成测试文本(Lorem Ipsum)Lorem Ipsum是一段用于测试排版效果的占位文字，没有实际含义。在Emmet中，可以通过lorem快速生成，同时还可以指定生成单词的个数。例如lorem10，将生成：1Lorem ipsum dolor, sit amet consectetur adipisicing elit. Alias, neque?缩写格式（不要有空格）以上为Emmet的基本缩写语法，需要注意的是在Emmet中，空格会被当做停止符号，如果你的缩写中含有空格，Emmet会停止缩写解析，举个例子，下面的缩写是不起作用的：1(header &gt; ul.nav &gt; li*5) + footerCSS缩写属性缩写Emmet允许将值直接注入缩写，如果你想要得到margin: 10px，可以简单的输入m10。如果有多个属性值，可以用连字符-分割多个属性值，例如，m10-20可以扩展为：1margin: 10px 20px;如果需要负值，可在属性值前多加一个横杠-。例如，m-10--20可生成：1margin: -10px -20px;默认情况下，当使用整数值展开缩写时，Emmet会以px作为单位输出：m10→margin: 10px;。如果使用浮点数值扩展缩写，则以em单位输出：m1.5→ margin: 1.5em。如果想要明确地指出单位名称，只需要将其放置在值之后：12m1.5ex→ margin: 1.5ex;m10foo→ margin: 10foo;如果已明确地定义单位，则不需要使用连字符来分隔值：12m10ex20em→ margin: 10ex 20em;m10ex-5→ margin: 10ex -5px;单位别名Emmet提供一些常用值的别名，可以使用别名而不是完整单位。p → %e → emx → ex12w100p → width: 100%m10p30e5x → margin: 10% 30em 5ex颜色值Emmet支持十六进制颜色值，如下所示：c#3→ color: #333;。该#是值分隔符，因此不需要使用连字符来分隔。例如，bd5#0s展开为border: 5px #000 solid：#符号分隔颜色值和5，因为s（别名solid）不是十六进制字符，它可以在没有-值分隔符的情况下使用。在Emmet中，可以将1个，2个，3个，6个字符写为颜色值：123#1 → #111111#e0 → #e0e0e0#fc0 → #ffcc00无单位属性一些CSS属性是没有单位的，例如：12lh2→ line-height: 2;fw400→ font-weight: 400;!important语法可以在任何CSS缩写的末尾加上!以生成!important。1234/* p!+m10e! */padding: !important;margin: 10em !important;供应商前缀CSS3的新特性为前端开发带来了很多便利，可以用少量代码实现复杂功能，但由于其还没有作为规范兼容所有浏览器，致使我们不得不编写大量冗余代码，在属性前加上不同前缀以兼容不同浏览器。在Emmet中，我们可以通过在属性名或者其缩写前加上连字符-来自动创建此属性的带前缀代码。例如，输入-bdrs可生成：123-webkit-border-radius: ;-moz-border-radius: ;border-radius: ;此外，你还可以显式地控制具体生成哪几个浏览器前缀或者先后顺序。假如你只想生成transform属性的webkit和moz前缀，这种情况下，可以输入-wm-trf，将会生成：123-webkit-transform: ;-moz-transform: ;transform: ;Emmet中支持的单字母供应商前缀为：w： webkitm： mozs： mso： o渐变背景CSS3中新增加了一条属性linear-gradient用于制作出渐变的效果。但由于该属性的参数比较复杂，而且需要添加前缀，无疑需要生成大量代码。在Emmet中使用lg()指令即可快速生成，例如：使用lg(left, #fff 50%, #000)可以直接生成：12345background-image: -webkit-gradient(linear, 0 0, 100% 0, color-stop(0.5, #fff), to(#000));background-image: -webkit-linear-gradient(left, #fff 50%, #000);background-image: -moz-linear-gradient(left, #fff 50%, #000);background-image: -o-linear-gradient(left, #fff 50%, #000);background-image: linear-gradient(left, #fff 50%, #000);模糊匹配如果有些缩写你不确定，Emmet会根据你的输入匹配最接近的语法，比如输入ov:h、ov-h、ovh和oh，生成的结果是相同的：1overflow: hidden定制如果Emmet现有的功能仍不能满足你的需求，还可以选择定制插件：添加新缩写或覆盖现有缩写，可修改snippets.json文件更改Emmet操作和解析程序的行为，可修改preferences.json文件定义如何生成HTML或XML代码，可修改syntaxProfiles.json文件]]></content>
      <categories>
        <category>网摘分享</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于1行核心JS代码实现简单的富文本编辑器]]></title>
    <url>%2Farticles%2F1452700591%2F</url>
    <content type="text"><![CDATA[之前的一个博客项目中，有使用富文本编辑器的需求，考虑到已有很多功能完备且强大的编辑器，从零开始开发新的编辑器没有必要，且在有限时间内完成质量无法保证，便直接选用了TinyMCE供项目使用，类似的还有Quill Rich Text Editor等。近期的学习过程中又遇到类似的问题，于是整理了手头的资料，写了一个Demo上传至Github，可以在STEditor体验效果，具体详情可前往我的Github仓库查看。之前的一个博客项目中，有使用富文本编辑器的需求，考虑到已有很多功能完备且强大的编辑器，从零开始开发新的编辑器没有必要，且在有限时间内完成质量无法保证，便直接选用了TinyMCE供项目使用，类似的还有Quill Rich Text Editor等。近期的学习过程中又遇到类似的问题，于是整理了手头的资料，写了一个Demo上传至Github，可以在STEditor体验效果，具体详情可前往我的Github仓库查看。原理当一个HTML文档切换到设计模式时，document暴露execCommand方法，该方法允许运行命令来操纵可编辑内容区域的元素。大多数命令影响document的selection（粗体，斜体等），而其他命令插入新元素（添加链接）或影响整行（缩进）。当使用contentEditable时，调用execCommand()将影响当前活动的可编辑元素。以上描述引用自MDN文档中关于document.execCommand的介绍，从中可以看出，要实现基本的编辑器功能，只需要使用contentEditable属性设置文本区域可编辑，再配合document.execCommand方法操纵可编辑区域元素即可。语法1bool = document.execCommand(aCommandName, aShowDefaultUI, aValueArgument)返回值为Boolean，如果是false表示操作不被支持或未被启用。需要注意的是，该命令只有在实际调用时生效，如果直接在浏览器中输入，会返回false，不能以返回值校验浏览器的兼容性。具体参数如下：aCommandName一个DOMString，为命令名称，必选项，可用命令列表可参考MDN给出的命令。aShowDefaultUI一个Boolean，是否展示用户界面，一般为false。aValueArgument可选项，一些命令需要额外的参数，如插入链接时需要提供链接对应的url，默认为null。实现我们要实现的编辑器大体分为两个部分，顶部用于格式控制的控制区域，和底部用于输入和显示的文本区域。可以先在HTML文档中写出基本结构。1234&lt;div id="container"&gt; &lt;div id="menubar"&gt;&lt;/div&gt; &lt;div id="content" contenteditable="true"&gt;&lt;/div&gt;&lt;/div&gt;因为要实现文本区域可编辑，所以要在文本区域设置contenteditable属性为true。控制区域接下来的工作主要分为两块，控制区域和文本区域，和基本HTML结构对应。控制区域主要为各种格式化按钮的绘制，基本结构可以采用&lt;a&gt;标签，也可以使用&lt;button&gt;标签，这里我使用的是后者，同时结合Font Awesome显示图标。123456789&lt;!-- 调整文本为粗体 --&gt;&lt;button type="button" data-command="bold" title="Bold"&gt; &lt;span&gt;&lt;i class="fa fa-bold fa-lg" aria-hidden="true"&gt;&lt;/i&gt;&lt;/span&gt;&lt;/button&gt;&lt;!-- 设置文本为1级标题 --&gt;&lt;button type="button" data-command="formatBlock" data-value="H1" title="Heading1"&gt; &lt;span&gt;Heading 1&lt;/span&gt;&lt;/button&gt;上面的两段代码分别对应加粗和添加块式标签两个命令，区别在于前者仅需要传递命令名称，后者需要传递一个标签名称字符串参数以标识创建哪种块元素。这里我们采用data-*这个HTML5新增的自定义Attribute，详情可参考这里。data-command标识命令名称，data-value标识命令需要的额外参数，如果有的话。文本区域HTML页面中完成data-*的设置后，接下来要做的是当点击控制区域触发click事件时，获取事件源传过来的参数，进行处理后响应到文本区域中选中的文本上。我们只考虑如何传递参数，调用命令，也就是上面提到的document.execCommand，暂不关心浏览器如何执行对应命令。12345function changeStyle(data) &#123; //调用document.execCommand方法进行编辑 data.value ? document.execCommand(data.command, false, data.value) : document.execCommand(data.command, false, null);&#125;核心的处理函数如上，这里我们在执行命令前做一个简单判断，看是否有除命令名称外的额外参数。在JS文件中，我们可以通过如下方式读写data-*的值：123456//获取加粗按钮var btn = document.querySelector("#bold-btn");//获取加粗按钮对应的commandvar command = btn.getAttribute("data-command");//设置加粗按钮对应的命令为斜体btn.setAttribute("data-command", "italic");也可以通过HTML5原生的APIdataset来读写data-*：123456//获取加粗按钮var btn = document.querySelector("#bold-btn");//获取加粗按钮对应的commandvar command = btn.dataset.command;//设置加粗按钮对应的命令为斜体btn.dataset.command = "italic";如果你使用jQuery，还可以使用下面的方式：123456//获取加粗按钮var btn = $("#bold-btn");//获取加粗按钮对应的commandvar command = btn.attr("data-command");//设置加粗按钮对应的命令为斜体btn.attr("data-command", "italic");这里我使用HTML5原生的dataset获取参数，在button对应的事件处理函数中调用changeStyle方法实现文本编辑。到这里基本的功能已经实现，剩下的工作就需要靠CSS完成了。下面是该Demo的预览：小结实际上，本文中的富文本编辑器仅是最简单的一种实现，所有的命令调用都通过document.execCommand这一条命令，容易出现覆盖现象，且没有重写样式，所有的文字样式均由浏览器默认指定，不同浏览器显示效果也有差异，存在问题显而易见。现有的功能完善且强大的编辑器多有自己的实现，从样式重写到事件监听，不过分依赖于原生的接口，可实现功能更丰富，也更稳定。总体表现更出色，实现起来也要复杂的多，不在本文要讨论的范围内。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Font Awesome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来自澳大利亚绘本艺术家陈志勇的 Cicada(蝉)]]></title>
    <url>%2Farticles%2F3824705080%2F</url>
    <content type="text"><![CDATA[Everything is calm.The voice of the cicadapenetrates the rocks.一切都很平静蝉鸣穿透了岩石图片来源Shaun Tan主页]]></content>
      <categories>
        <category>网摘分享</category>
      </categories>
      <tags>
        <tag>网摘分享</tag>
        <tag>绘本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基础教程(四)：功能添加与优化]]></title>
    <url>%2Farticles%2F1153730074%2F</url>
    <content type="text"><![CDATA[在参考本文时，你应该已经完成了博客的搭建，部署和基本配置。个人网站已经能够正常工作。本文主要包括Hexo中一些实用的功能，模块插件等，意在优化博客使用，文中主要涉及两个_config.yml配置文件：站点配置文件（根目录下）和主题配置文件（主题文件夹下），没有特殊说明主题均以Theme-AD为例。在参考本文时，你应该已经完成了博客的搭建，部署和基本配置。个人网站已经能够正常工作。本文主要包括Hexo中一些实用的功能，模块插件等，意在优化博客使用，文中主要涉及两个_config.yml配置文件：站点配置文件（根目录下）和主题配置文件（主题文件夹下），没有特殊说明主题均以Theme-AD为例。添加RSSRSS，简易信息聚合，是一种基于XML的描述和同步网站内容的格式。它允许你订阅感兴趣的博客，通过RSS阅读器聚合信息，实时推送内容更新，以有组织的方式快速查看。安装RSS插件1npm install hexo-generator-feed在站点配置文件_config.yml中找到Extensions，添加：1234567891011# Extensions## Plugins: https://hexo.io/plugins/#RSS订阅feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: content_limit_delim: &apos; &apos;参数的含义：type：RSS的类型path：文件路径，默认/atom.xmllimit：展示文章的数量，0或者false代表全部hub：content：在RSS中是否包含文章正文内容，true/false，默认为falsecontent-limit：指定内容的长度作为摘要，仅在content为false和没有自定义的描述出现时生效content-limit-delim：上面截取描述的分隔符，截取内容是以指定的这个分隔符作为截取结束的标志。在达到规定的内容长度之前最后出现的这个分隔符之前的内容，防止从中间截断此时，你网站的RSS链接为 域名/atom.xml。修改主题配置文件，开启RSS页面功能：1234nav: - name: "订阅RSS" path: "/atom.xml"代码压缩不少人使用gulp对博客进行压缩，这里使用插件hexo-all-minifier。这个插件集成了对html，css，js，image的优化，合并重复代码，去除多余空格，用算法压缩图片。压缩后的博客，在加载速度上会有较大的提升。安装插件1npm install hexo-all-minifier --save在站点配置文件_config.yml中找到Extensions，添加：1234567891011121314151617181920212223242526#文件压缩html_minifier: enable: true ignore_error: false exclude:css_minifier: enable: true exclude: - '*.min.css'js_minifier: enable: true mangle: true output: compress: exclude: - '*.min.js'image_minifier: enable: true interlaced: false multipass: false optimizationLevel: 2 pngquant: false progressive: false文章链接唯一化默认情况下，Hexo生成的超链接都是绝对链接。更改文章标题，变更文章所属分类，发布时间等都可能导致文章链接改变，不利于搜索引擎收录，也不利于分享。唯一的永久链接显然是更好的选择。安装插件1npm install hexo-abbrlink --save在站点配置文件_config.yml中找到permalink，修改为：1permalink: articles/:abbrlink/其中articles/可自行替换。搜索引擎认为对于一般的中小型站点，3层足够承受所有的内容了，所以蜘蛛经常抓取的内容是前3层，而超过3层的内容蜘蛛认为那些内容并不重要，所以不经常爬取。出于这个原因permalink的配置中最好不要超过2个斜杠。在站点配置文件中添加：1234# abbrlink configabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: dec # 进制：dec(default) and hexGithub分支进行多终端工作我们通过hexo d上传部署到github的是Hexo编译后的文件，也就是本地目录中自动生成的.deploy_git文件夹中的内容，用来生成网页，源文件没有包含在内。这种情况下，如果我们的电脑坏了，或者换用其他的电脑，没有博客的源文件，就无法进行更新。所以我们可以利用Github的分支系统，将源文件上传至项目仓库的另一个分支。这样，更换电脑时，只需要进行简单配置并同步Github文件，就可以继续使用。创建分支在博客项目所在仓库yourname.github.io创建新分支hexo（分支名可自定义），用于存放源文件，我们只需更新hexo分支上的内容即可，master分支在执行hexo d部署时会自动更新。在该仓库的settings中，可以设置hexo分支为默认分支。这样之后更新hexo分支内容时可以不用每次都指定分支。初始化仓库在本地创建文件夹，建议和博客项目放在同一父目录下，方便管理。进入文件夹，打开Git Bash，输入：1git clone git@github.com:gzhanuo/gzhanuo.github.io.git .克隆代码到本地，因为默认分支已设为hexo，所以执行clone操作时只clone了hexo分支的内容。如果hexo不为默认分支，可输入：1git clone -b hexo git@github.com:gzhanuo/gzhanuo.github.io.git .在克隆到本地的代码中，删除除.git文件夹外的所有文件。将之前博客项目中除.deploy_git外的所有源文件拷贝过来。拷贝过来的源文件中有一个.gitignore文件，用于声明不被git记录的文件。如果没有可以自行创建，添加如下内容：12345678.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/_config.yml_config.yml文件中可能包含加密等相关隐私信息，所以不建议上传配置文件。如果之前通过clone操作下载过主题文件，应删除主题文件夹下的.git文件夹，电脑设置显示隐藏文件，检查是否有该文件夹。因为git不能嵌套上传，可能导致主题文件上传出错。上传源文件至hexo分支依次执行以下命令：123git add .git commit -m "add branch"git push origin hexo #如果设置hexo为默认分支可执行git push查看Github对应仓库，博客源文件已上传至hexo分支。更换电脑操作更换电脑后，操作流程和之前环境搭建类似。这里仅列出步骤，具体指令代码可参考Hexo基础教程(一)：博客搭建与部署。安装Git安装Node.js配置SSH安装HexoHexo安装后不需要初始化，直接在任意文件夹下，执行：1git clone -b hexo git@github.com:gzhanuo/gzhanuo.github.io.git .在该文件夹中，执行：12npm installnpm install hexo-deployer-git --save生成文件，部署到Github：12hexo ghexo d然后就可以开始继续写新的博客。添加Google Analytics使用Google分析可以在后台看到你网站的访问数，访问时间，用户分布等信息，可以帮助你更有效地掌握网站情况，更好地进行网站管理。访问Google Analytics，按照提示填写相关信息，获取跟踪ID。在主题配置文件中找到analytics:,修改关于google的配置：1234analytics: google: enable: true #开启对Google的自动推送 id: #填写上一步获取的跟踪ID执行hexo d重新部署网站，在Google分析后台发送测试流量即可在首页看到实时流量报告。SEO优化(Google)刚建站时，搜索引擎是没有收录我们的网站的。可以在搜索引擎中输入site:&lt;域名&gt;来查看个人网站是否已被搜索引擎收录。安装插件在Git Bash中执行以下命令，该插件用于生成sitemap文件：1npm install hexo-generator-sitemap --save在站点配置文件中添加：12sitemap: path: sitemap.xml在站点配置文件中找到url，修改为个人网站的url：1234# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://indexmoon.comroot: /添加robots文件在站点source文件夹下新建robots.txt文件，文件内容格式如下：123456789101112131415User-agent: *Allow: /Allow: /archives/Allow: /tags/Allow: /categories/Allow: /about/Allow: /friends/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendor/Disallow: /styles/Sitemap: https://indexmoon.com/sitemap.xmlrobots是站点与spider沟通的重要渠道，站点通过robots文件声明本网站中不想被搜索引擎收录的部分或者指定搜索引擎只收录特定的部分。详细信息可以参考百度搜索资源平台给出的解释。执行hexo d重新部署后，在博客根目录public文件夹下可以看到生成的sitemap.xml和robots.txt文件。你可以在百度搜索资源平台检测robots.txt文件是否能正常工作。提交站点到Google打开Google SearchConsole，添加个人网站地址，资源类型可视个人情况选择，根据提示完成验证。点击左侧站点地图，输入站点地图网址，确认提交。验证站点是否被收录点击左侧网址检查，输入网站域名下的任意网址，查看显示结果。在Google中输入site:&lt;域名&gt;查看搜索结果。Google抓取网页需要一定时间，站点地图提交后可能不会立即编入索引。如果验证结果没有收录，可以在几分钟后再次验证。至此，你的个人网站已被Google收录。如果你对站点地图文件做出了更改。Google会在下次抓取你的网站时发现你的更改，所以不必重新提交已知的站点地图。开启SEO优化为了使网站更容易被搜索引擎收录，获得更高SEO，主题提供了百度、谷歌和360这3种搜索引擎的自动推送服务。在主题配置文件中找到analytics，开启推送服务：123456789analytics: baidu: enable: true #开启对Baidu的自动推送 google: enable: true #开启对Google的自动推送 id: #Google跟踪代码的id "360": enable: true #开启对360的自动推送 id: #360跟踪代码的id文章内图片处理在使用Markdown写文章时，图片是不能直接上传的。一般来说，可以手动上传至七牛云，再把链接写到Markdown中；或者通过修改站点配置文件在新建Markdown时创建同名文件夹，将图片放入该文件夹中，通过相对路径引用，部署时和文章一同上传至Github。一键上传七牛云如果你使用七牛云处理图片，可以试一试一键贴图工具qimage-win，支持本地文件、截图及网络图片一键上传七牛云，并粘贴资源链接至当前编辑器。有Windows和Mac两个版本。按照要求配置后，使用自定义快捷键即可上传图片至七牛云，同时返回图片引用。本地上传方法一如果你添加本地图片，需要进行如下配置：在站点配置文件_config.yml中找到post_asset_folder，设置为true。之后在新建Markdown文件时，Hexo会自动创建一个与该文件同名的文件夹，你可以将与文章相关的资源放在此文件夹中，在文章中方便地引用。在博客根目录下打开Git Bash，执行：1npm install hexo-asset-image --save运行hexo n &quot;xxx&quot;创建新Markdown文件，查看/source/_posts文件夹，存在xxx.md和一个xxx文件夹。将所需图片，如test.png，放入xxx文件夹，然后只需在xxx.md中按照Markdown的语法引入图片即可：1![图片描述信息](xxx/test.png)依次执行以下命令：123hexo cleanhexo ghexo s访问http://localhost:4000查看是否有图片显示，确认无误后执行hexo d部署到远程仓库，访问个人网站即可看到图片。方法二上述方法可以解决本地图片的使用问题，但为每个文章建立同名文件夹不便于管理。你可以在本地source文件夹下建立images文件夹，将文章中用到的所有图片放置在同一文件夹下，上传至远程仓库，此时无需修改站点配置文件，也不需要安装插件。同时，主题提供了配置静态图片CDN的功能，更改主题文件夹下的package.json文件的imgcdn字段，例如：123&#123; "imgcdn": "https://indexmoon.com/blog-static"&#125;文章中如果使用了图片资源，例如![](/images/test.png)。都会被替换为https://indexmoon.com/blog-static/images/test.png。借助此功能，可以将静态图片资源部署在CDN或者其他服务器上，文章仓库仅仅存放文章对应的Markdown。避免随着文章数量的增加，静态图片资源造成的仓库大小不断膨胀。注意事项如果你使用方法一上传本地图片，同时又使用了文章链接唯一化的插件，你可能会发现，图片并不能正常显示。我们现在假设有一Markdown文件标题为test.md，其同名文件夹下有一图片为indexmoon.png，在Markdown文件中引用该图片的语法为![](test/indexmoon.png)。进入博客根目录下的node_modules文件夹，找到hexo-asset-image，也就是我们安装的图片上传插件，打开文件夹下的index.js文件，其内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; // For windows style path, we replace '\' to '/'. var src = $(this).attr('src').replace('\\', '/'); if(!/http[s]*.*|\/\/.*/.test(src))&#123; // For "about" page, the first part of "src" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != ''; &#125;); if(linkArray[linkArray.length - 1] == srcArray[0]) srcArray.shift(); // src = srcArray.join('/'); src = srcArray.pop(); $(this).attr('src', '/' + link + src); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;);从代码中可以看出，该插件通过截取永久链接link中域名后面的部分，与文章中所使用的图片地址src拼接，获得HTML文件中图片的正确src。Hexo默认的永久链接格式为：:year/:month/:day/:title/，假设发布时间为5月8号，此时这篇文章发布后生成的永久链接为http://yourname.github.io/2019/05/08/test/，代码运行后得到的linkArray为[2019，05，08，test]，srcArray为[test，indexmoon.png]，生成的HTML文件中图片的引用结果为&lt;img src=&quot;/2019/05/08/test/indexmoon.png&quot;&gt;，这时图片可以正常显示。当我们使用插件后，Hexo永久链接格式为articles/:abbrlink/，因为abbrlink和title不等，第42行代码没有执行，得到的图片引用结果为&lt;img src=&quot;/articles/abbrlink/test/indexmoon.png&quot;&gt;，路径不存在，所以无法正常显示图片。解决方案有两个，一是将代码中第43行的src = srcArray.join(&#39;/&#39;);改为src = srcArray.pop();，Markdown文章中图片引用格式不变；二是不改动代码，Markdown文章中引用图片时直接使用![](indexmoon.png)，去掉路径中同名文件夹那一层。参考资料hexo摸爬滚打之进阶教程Theme Art Design中文文档hexo史上最全搭建教程]]></content>
      <categories>
        <category>理论 &amp; 教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基础教程(三)：网站基本配置与主题设置]]></title>
    <url>%2Farticles%2F1986384094%2F</url>
    <content type="text"><![CDATA[博客根目录下的_config.yml，是整个Hexo的配置文件，可以在其中修改大部分的配置。这里仅列出部分初期需要注意的内容，详细可参考官方配置文档。需要注意的是配置文件依靠缩进来确定元素间的从属关系，请使用空格缩进，并保证缩进正确，配置才可生效。Hexo基本配置博客根目录下的_config.yml，是整个Hexo的配置文件,可以在其中修改大部分的配置。这里仅列出部分初期需要注意的内容，详细可参考官方配置文档。需要注意的是配置文件依靠缩进来确定元素间的从属关系，请使用空格缩进，并保证缩进正确，配置才可生效。网站参数描述title网站标题subtitle网站副标题description网站描述author你的名字language网站使用的语言timezone网站时区。Hexo默认使用你电脑的时区。时区列表。比如说：America/New_York,Japan,和UTC 。其中，description主要用于SEO，告诉搜索引擎一个关于你站点的简单描述，通常建议在其中包含你网站的关键词。author参数用于主题显示文章的作者。网址参数描述默认值url网址root网站根目录permalink文章的永久链接格式:year/:month/:day/:title/permalink_defaults永久链接中各部分的默认值这里，你需要把url设置成你的网站域名。permalink即新建文章时生成的链接格式，例如新建文章test.md，此时生成的链接为http://yoursite.com/2019/03/26/test。以下为官方示例，想要深入了解可以在官方文档中查看永久链接。参数结果:year/:month/:day/:title/2013/07/14/hello-world:year-:month-:day-:title.html2013-07-14-hello-world.html:category/:titlefoo/bar/hello-world如果你的网站存放在子目录中，例如http://yoursite.com/blog，则需要将url设为http://yoursite.com/blog并把root设为/blog/。分页参数描述默认值per_page每页显示的文章量 (0 = 关闭分页功能)10pagination_dir分页目录page扩展参数描述theme当前主题名称。值为false时禁用主题deploy部署部分的设置theme是你所选择的主题，更换主题时，需要将所下载主题文件放在themes文件夹下，再修改这个参数。deploy是部署部分的设置，其中repo表示仓库，branch表示仓库的分支，具体的修改方法在前面的文章中已有提及，这里不再赘述。Hexo基本操作Front-matterFront-matter是文件最上方以---分隔的区域，用于指定个别文件的变量，举例来说：1234---title: Hello Worlddate: 2013/7/13 20:46:25---以下是预先定义的参数，可以在模板中使用这些参数值进行设置。参数描述默认值layout布局title标题date建立日期文件建立日期updated更新日期文件更新日期comments开启文章的评论功能truetags标签（不适用于分页）categories分类（不适用于分页）permalink覆盖文章网址只有文章支持分类和标签。其中，分类具有顺序性和层次性，也就是说Foo, Bar不等于Bar, Foo；而标签没有顺序和层次。123categories:- Diary- LifeHexo不支持指定多个同级分类，也就是说，如果设置上面的指定方法，会使分类Life成为Diary的子分类，而不是并列分类。布局(Layout)你可以执行下列命令来创建一篇新文章：1hexo new [layout] &lt;title&gt;Hexo有三种默认布局：post、page和draft，它们分别对应不同的路径，而你自定义的其他布局和post相同，都将储存到source/_posts文件夹。布局路径postsource/_postspagesourcedraftsource/_draftsHexo默认的布局是post，新建的文章都保存在source文件夹下_posts里面。你可以在创建文章时指定布局，也可以通过修改_config.yml中的 default_layout参数来指定默认布局。如果你不想你的文章被处理，可以将Front-Matter中的layout: 设为false。页面(Page)如果你想另起一页，可以使用：1hexo new page pageName系统会在source文件夹下创建一个pageName文件夹，以及其中的index.md，博客搭建完成后的about页面，分类和标签页面都需要通过此方式自行创建。草稿(Draft)draft是草稿的意思，是Hexo的一种特殊布局，这种布局在建立时会被保存到source/_drafts文件夹，默认不会在页面中显示。1hexo new draft &lt;title&gt;如果你的草稿写完了，可通过以下命令进行预览：1hexo server --draft在本地端口中开启服务即可进行预览。如果草稿确认无误，想要发布，可以通过publish命令将草稿移动到source/_posts文件夹。1hexo publish draft &lt;title&gt;模板(Scaffold)在新建文章时，Hexo会根据scaffolds文件夹内相对应的文件来建立文件，例如：1hexo new photo "My Gallery"在执行这行指令时，Hexo会尝试在scaffolds文件夹中寻找photo.md，并根据其内容建立文章，以下是可以在模版中使用的变量：变量描述layout布局title标题date文件建立日期主题设置Hexo使用landscape作为默认主题，如果你觉得不符合自己的使用习惯，可以选择喜欢的主题进行修改。主题选用目前比较受欢迎为NexT主题，简洁清爽，功能全面，网上关于该主题的教程也较多。如果你不打算用NexT，Hexo官网有200多个主题可供选择，如果你觉得官网主题太多不便筛选，也可以去知乎找找推荐，或者直接在Github搜索hexo theme，按star数量排序，排名靠前的主题都不差。本站主题使用GodBMW的Theme-AD，主题作者提供了详细的中文文档，感兴趣的可以前往查看。选定主题后，需要在Github下载主题文件，在themes文件夹下新建文件夹存放该文件，然后修改站点根目录下的_config.yml中的theme字段为主题文件夹名称，执行以下命令，重新生成相关文件，引擎会自动搜索themes文件夹中已配置主题进行渲染。在本地查看预览即可看到主题效果。123hexo cleanhexo ghexo s主题结构从Github下载的主题可能有如下结构：123456.├── _config.yml├── languages├── layout├── scripts└── source_config.yml主题的配置文件，修改时会自动更新，无需重启服务器。可在此修改主题的有关配置，需要和Hexo根目录的_config.yml区分。languages语言文件夹，存放有关网站语言的配置文件。如果要使用国际化功能，需要先在站点根目录_config.yml中修改language设定。需要注意的是，不同主题语言文件的命名并不都相同，language设定应以各主题languages下的语言文件命名为准，否则可能会有意想不到的结果。layout布局文件夹，用于存放主题的模板文件，决定了网站内容的呈现方式。scripts脚本文件夹，在启动时，Hexo会载入此文件夹内的JavaScript文件。source资源文件夹，除了模板以外的Asset，如CSS，JavaScript等。]]></content>
      <categories>
        <category>理论 &amp; 教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基础教程(二)：个人域名绑定]]></title>
    <url>%2Farticles%2F1318032967%2F</url>
    <content type="text"><![CDATA[利用Hexo + Github Pages完成博客搭建和部署后，现在你的个人博客的地址是http://yourname.github.io，如果不满足于用github.io访问网站，可以为博客绑定个人域名。利用Hexo + Github Pages完成博客搭建和部署后，现在你的个人博客的地址是http://yourname.github.io，如果不满足于用github.io访问网站，可以为博客绑定个人域名。域名申请域名注册商有很多，国内的万网，国外的GoDaddy等等。区别在于国内域名注册后需要备案，因为政策因素也可能随时被停用，相对的，国外注册域名在交流和沟通方面不如国内方便，而因为没有国内的政策限制，域名注册商通常会给予用户域名的完全控制权与转移权，在安全性方面可能比国内稍差。本站域名申请使用国外域名平台Namesilo，是目前价格较便宜的域名平台，支持支付宝、Paypal、Visa等多种付款方式，提供免费的域名隐私保护，性价比较高，用户评价也不错。注册用户账号访问Namesilo官网，注册用户账号邮箱可以填QQ邮箱，国家选China，其他必填信息可根据实际情况填写。Namesilo提供免费的域名隐私保护服务，所以注册信息可以尽量真实，不需要担心信息泄露。注册完成后，需要通过验证邮件激活账户。如果没有收到验证邮件，可在Namesilo的My Account中选择重发验证邮件。选择域名账户激活后，进入Namesilo首页，在domain search中输入域名，点击search页面显示的搜索结果中，绿色代表可注册，选择需要的域名，勾选对应后缀名，点击下方register checked domains购买域名跳转至购买页面后，可以设置购买时间等，在Promotion Code输入优惠码，点击submit可以优惠1美元，设置完成后点击continue这里，Configuration Options下第2个选项NameServers用于设定域名解析服务器，可在后续步骤中更改；Auto-Renew表示自动续费；Privacy Setting表示Namesilo提供的域名隐私保护服务，如果不需要可以选择No Privacy。接着会跳转至支付页面，Namesilo提供多种付款方式，可选择支付宝付款使用手机支付宝扫码即可完成支付，同时注册邮箱会收到有关邮件NS修改国外的域名使用默认的域名服务器（NS）解析可能较慢，网上很多人推荐转到DNSPod，也就是说指派DNSPod进行域名的解析工作。注册DNSPod账号在DNSPod官网注册账号，在域名解析页面选择添加域名，添加已购买的域名。完成后点击查看，DNSPod提供两条默认的NS记录：12f1g1ns1.dnspod.netf1g1ns2.dnspod.net修改Namesilo中NS记录登录Namesilo，选择Manage My Domains，进入域名管理页面。勾选你的域名，点击选项栏中的Change Nameservers。将NS1，NS2改为DNSPod提供的两条NS记录，删除第三条NS记录，点击提交。更改成功后，Name Servers处显示为DNSPod提供的NS记录。NS的修改需要一段时间，一般最长48小时生效，个人情况来看，10分钟左右即可完成更改。域名解析打开Git Bash或cmd命令行控制台，输入：1ping yourname.github.io返回结果为自己博客站点的IP地址。登录进入DNSPod的域名控制台，选择要解析的域名，添加如下解析内容：解析时，记录类型选A或CNAME，A记录的记录值为上一步得到的IP地址，CNAME记录的记录值为你的Github Pages博客域名。同时添加两条记录可保证无论是否添加www都可以访问。主机记录就是域名前缀，常见用法有：www：解析后的域名为www.aliyun.com@：直接解析主域名aliyun.com：泛解析，匹配其他所有域名.aliyun.commail：将域名解析为mail.aliyun.com，通常用于解析邮箱服务器二级域名：如：abc.aliyun.com，填写abcGithub设置登录Github，进入博客站点对应的仓库，选择Settings，设置Custom Domain为你的域名。Github Pages默认支持https，可以通过勾选Enforce HTTPS使用https访问网站。CNAME文件创建在本地博客站点根目录的source文件夹下，创建一个名为CNAME的文件（文件名大写，无后缀），填写域名信息。这里，域名加不加www均可，从网上已有经验来看：如果不填写www，如indexmoon.com，那么无论是访问http://www.indexmoon.com还是http://indexmoon.com，都会自动跳转到http://indexmoon.com如果填写www，如www.indexmoon.com，那么无论是访问http://www.indexmoon.com还是http://indexmoon.com，都会自动跳转到http://www.indexmoon.com如果填写的是其它子域名，如abc.indexmoon.com，那么访问http://abc.indexmoon.com没问题，但是访问http://indexmoon.com，不会自动跳转到http://abc.indexmoon.com在绑定了新域名后，原来的yourname.github.io域名依旧可以使用，访问时会自动跳转至已绑定的个人域名。在Git Bash中，输入以下命令：123hexo cleanhexo ghexo d一段时间后，在浏览器中输入自己的域名，即可正常访问。至此，你的个人域名已绑定至博客所在地址。]]></content>
      <categories>
        <category>理论 &amp; 教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基础教程(一)：博客搭建与部署]]></title>
    <url>%2Farticles%2F3433589275%2F</url>
    <content type="text"><![CDATA[市面上的博客很多，CSDN，博客园，简书等等，可以直接在线编辑发布，文章也容易被百度抓取。但往往不太自由，会受到平台的各种限制，过分商业化带来的大量广告也会影响体验。而自己购买域名和服务器，搭建博客的成本太高。定期维护需要大量时间精力，到后面可能就不了了之。无意接触到Hexo，配合Github Pages托管，免去了不必要的麻烦，可以安心写作。一直有记录的习惯，虽然不成体系，但日常的想法和不时的灵感也还需要表达，所以便有了搭建一个单独的博客的想法。Hexo简介Hexo是一款基于Node.js的静态博客框架，使用Markdown（或其他渲染引擎）解析文章，依赖少易于安装，可在几秒内利用现有主题生成静态网页。框架提供了很详细的中文文档，大家可以进入Hexo官网查看。搭建环境准备安装GitGit是一个先进的分布式版本控制工具，可以有效处理不同规模的项目版本管理。这里用于管理你的Hexo文章，将本地的博客上传至Github。到Git官网选择合适的版本下载，安装后会有一个Git Bash的命令行工具，之后用该工具操作Git。检查是否安装成功：1git --version正常显示版本号，无报错即为安装成功。另外，Windows环境下在Git安装完成后，可以使用Git Bash来进行后续命令行操作。安装Node.jsHexo基于Node.js，所以需要安装Node.js及npm工具。可进入Node.js中文网下载，选择LTS（长期支持版本）即可。检查是否安装成功：12node -vnpm -v正常显示版本号，无报错即为安装成功。博客本地搭建安装Hexo右键打开Git Bash，输入命令：1npm install -g hexo-cli检查是否安装成功：1hexo -v初始化博客在电脑上新建一个文件夹作为博客的目录，例如这里我将博客目录设置为myblog，执行以下命令：123hexo init myblogcd myblognpm install博客目录介绍新建完成后，指定文件夹的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes_config.yml网站的配置信息，可以在此配置大部分的参数。package.json应用程序的信息，新添加的插件内容也会显示在这里，可以不做修改。scaffolds模板文件夹，新建文章时，Hexo会根据scaffolds来建立文件。Hexo的模板是指在新建的Markdown文件中默认填充的内容，我们可以在模板上添加自定义内容，比如categories，tags等。sourcesource文件夹是存放用户资源的地方，也就是我们的博客内容。初始设置两个文件夹，posts（文章）和drafts（草稿）。之后通过命令新建页面后，文件夹数量会增加。themes主题文件夹，用于存放主题文件包，Hexo会根据主题内容生成静态页面，默认主题为landscape，可根据个人喜好进行更改。博客本地效果Git Bash执行以下命令：12hexo -ghexo server启动hexo服务，访问http://localhost:4000即可看到生成的博客页面。使用Ctrl+C可关闭本地服务。博客Github部署创建个人仓库这里需要Github账号，如果没有可以去注册一个。登录Github，新建一个仓库，命名格式为：用户名.github.io。比如，我的用户名是gzhanuo，我的仓库名为gzhanuo.github.io。注意这里必须按此格式命名，只有这样，之后部署到GitHub pages的时候，才会被识别。配置SSH打开Git Bash，输入以下命令，生成本地密钥。这里用户名和邮箱仅作演示，用户名为你Github的用户名，邮箱为你Github的邮箱。12git config --global user.name "gzhanuo"git config --global user.email "gzhanuo@163.com"输入以下命令，检查输入是否正确：12git config user.namegit config user.email确认无误后，输入以下命令，创建SSH：1ssh-keygen -t rsa -C "youremail"此时在用户文件夹下，已经生成了.ssh文件夹，在本地找到这个文件夹。id_rsa是你这台电脑的私人秘钥，id_rsa.pub是公共秘钥。把公钥放在GitHub上，当你连接自己的Github账号时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过Git上传你的文件到GitHub上。在Github的设置中，找到SSH and GPG keys，新建SSH Key，以文本方式打开id_rsa.pub文件，将内容复制到Key，标题随便起，添加Key。部署代码到Github打开站点配置文件_config.yml，拉到最底部，找到deploy字段，按如下格式修改其内容：1234deploy: type: git repository: git@github.com:gzhanuo/gzhanuo.github.io.git branch: master其中repo字段可在Github获取：回到Git Bash，安装deploy-git ，用于使用命令部署到Github。1npm install hexo-deployer-git --save然后执行：123hexo clean //可省略hexo generatehexo deploy出现下图所示说明部署成功，此时代码已同步至Github。打开网址http://yourname.github.io就可以看到Hexo博客了。常用命令Hexo文档中命令很多，但你并不需要记住每一个。在博客的使用过程中，主要的命令如下：init用于新建网站1hexo init &lt;folder&gt;new用于新建文章或页面1hexo new [layout] &lt;title&gt;generate用于生成静态页面12hexo generatehexo g //简写deploy用于将内容部署到网站12hexo deployhexo -gpublish用于将内容从drafts文件夹移动到posts文件夹1hexo publish [layout] &lt;title&gt;server用于启动服务器进行预览，默认情况下，访问入口为http://localhost:4000/12hexo serverhexo s //简写实际上，除了第一次部署时，需要用到hexo init这个命令，平时写博客的过程中，最常用的就是：hexo n 新建文章/页面hexo g 生成静态页面hexo s 本地查看内容hexo d 部署到Github如果需要清除之前生成的内容，可以在生成静态页面前执行hexo clean，其他情况只需要以上四条命令即可。]]></content>
      <categories>
        <category>理论 &amp; 教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
